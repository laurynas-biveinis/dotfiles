#!/usr/bin/env python
"""Convert CAMT.053 XML to QIF

Currently tested banks are Citadele and Luminor. The QIFs are produced with the
intent to import them to Banktivity.

This is configured by a configuration file ~/.xml2qifrc which contains a
section per rule. Each rule must have some input and output keys.
Input keys:
- match (required): a regex to match one of the text fields. The following
  fields are attempted to match in this order, if present: creditor, debitor,
  unstructured information.
- amount (optional): if present, then must be equal.
- type (optional): if present, then must be equal. Currently supported types
  are:
  - loan: domain is "Loans, Deposits, & Syndications"
  - card_fee: domain is "Payments", family is "Customer Card Transaction", &
    subfamily is "Fees"
  - bank_service: domain is "Payments", family is "Other", & subfamily is
    "Other".
  - deposit: type is deposit.
Output keys, all of which are required:
- payee
- category

TODO(laurynas): transactions import to Banktivity in Cleared status,
regardless of whether QIF "Cleared status" is present and with what value.
Banktivity QIF exports omit it altogether.

TODO(laurynas): transfers between accounts do not work, but could be cleared
up with import rules
"""

import argparse
import configparser
import os
import re
import xml.etree.ElementTree as ET
from datetime import datetime
from enum import Enum, auto

CONFIG_FN = "~/.xml2qifrc"

NS = {"ns": "urn:iso:std:iso:20022:tech:xsd:camt.053.001.02"}
# XPaths inside a document:
XPATH_TRANSACTIONS = "ns:BkToCstmrStmt/ns:Stmt/ns:Ntry"
# XPaths inside a transaction:
XPATH_AMOUNT = ".//ns:Amt"
XPATH_BOOKING_DATE = ".//ns:BookgDt/ns:Dt"
XPATH_VALUE_DATE = ".//ns:ValDt/ns:Dt"
XPATH_TYPE_INDICATOR = ".//ns:CdtDbtInd"
XPATH_DOMAIN = ".//ns:BkTxCd/ns:Domn/ns:Cd"
XPATH_FAMILY = ".//ns:BkTxCd/ns:Domn/ns:Fmly/ns:Cd"
XPATH_SUBFAMILY = ".//ns:BkTxCd/ns:Domn/ns:Fmly/ns:SubFmlyCd"
XPATH_CREDITOR = ".//ns:NtryDtls/ns:TxDtls/ns:RltdPties/ns:Cdtr/ns:Nm"
XPATH_DEBITOR = ".//ns:NtryDtls/ns:TxDtls/ns:RltdPties/ns:Dbtr/ns:Nm"
XPATH_UNSTRUCTURED = ".//ns:NtryDtls/ns:TxDtls/ns:RmtInf/ns:Ustrd"

US_DATE_PREFIX = re.compile("^[0-9][0-9]/[0-9][0-9]/[0-9][0-9][0-9][0-9] .*$")


def add_from_string(mapping):
    """Add a from_string method to an enum class that maps the CAMT.053 strings
    in XML to enum values"""
    def decorator(enum_class):
        # Construct the reverse mapping once and store it as a class attribute
        reverse_mapping = {str_val: getattr(enum_class, enum_key) for str_val,
                           enum_key in mapping.items()}
        setattr(enum_class, '_str_to_enum', reverse_mapping)

        @classmethod
        def from_string(cls, string):
            return cls._str_to_enum[string]  # pylint: disable=E1101

        enum_class.from_string = from_string
        return enum_class
    return decorator


@add_from_string({'CRDT': 'DEPOSIT', 'DBIT': 'WITHDRAWAL'})
class TransactionType(Enum):
    """A CAMT.053 transaction type"""
    DEPOSIT = auto()
    WITHDRAWAL = auto()


@add_from_string({'PMNT': 'PAYMENTS', 'LDAS': 'LOANS_DEPOSITS_SYNDICATIONS'})
class TransactionDomain(Enum):
    """A CAMT.053 transaction domain"""
    PAYMENTS = auto()
    LOANS_DEPOSITS_SYNDICATIONS = auto()


@add_from_string({'CCRD': 'CUSTOMER_CARD_TRANSACTION',
                  'RCDT': 'RECEIVED_CREDIT_TRANSFER',
                  'ICDT': 'ISSUED_CREDIT_TRANSFER', 'OTHR': 'OTHER'})
class PaymentsTransactionFamily(Enum):
    """A CAMT.053 transaction family in the Payments domain"""
    CUSTOMER_CARD_TRANSACTION = auto()
    RECEIVED_CREDIT_TRANSFER = auto()
    ISSUED_CREDIT_TRANSFER = auto()
    OTHER = auto()


@add_from_string({'FTLN': 'FIXED_TERM_LOANS', 'MDOP': 'MISC_DEBIT_OPS'})
class LDASTransactionFamily(Enum):
    """A CAMT.053 transaction family in the Loans, Deposits & Syndications
    domain"""
    FIXED_TERM_LOANS = auto()
    MISC_DEBIT_OPS = auto()


@add_from_string({'POSD': 'POS_PAYMENT_DEBIT_CARD', 'FEES': 'FEES',
                  'DAJT': 'CREDIT_ADJUSTMENT', 'NTAV': 'NOT_AVAILABLE'})
class CCRDTransactionSubfamily(Enum):
    """A CAMT.053 transaction subfamily in a Customer Card Transaction (CCRD)
    family."""
    POS_PAYMENT_DEBIT_CARD = auto()
    FEES = auto()
    CREDIT_ADJUSTMENT = auto()
    NOT_AVAILABLE = auto()


@add_from_string({'ESCT': 'SEPA_CREDIT_TRANSFER'})
class ICDTTransactionSubfamily(Enum):
    """A CAMT.053 transaction subfamily in an Issued Credit Transfer (ICDT)
    family."""
    SEPA_CREDIT_TRANSFER = auto()


@add_from_string({'OTHR': 'OTHER'})
class OtherTransactionSubfamily(Enum):
    """A CAMT.053 transaction subfamily in an Other family"""
    OTHER = auto()


@add_from_string({'INTR': 'INTEREST'})
class MiscDebitOpsTransactionSubfamily(Enum):
    """A CAMT.053 transaction subfamily in a Miscellaneous Debit Operations
    family"""
    INTEREST = auto()


@add_from_string({'RIMB': 'REIMBURSEMENT'})
class FixedTermLoanTransactionSubfamily(Enum):
    """A CAMT.053 transaction subfamily in a Fixed Term Loans family"""
    REIMBURSEMENT = auto()  # Absolutely incorrect yet Luminor returns this


def collect_rules(config):
    """Collect transaction rewrite rules from the config file"""
    rules = []
    for section in config.sections():
        # Input
        type_key = config.get(section, "type", fallback="")
        amount = config.get(section, "amount", fallback="")
        regex = config[section]["match"]
        pattern = re.compile(regex)
        # Output
        payee = config[section]["payee"]
        category = config[section]["category"]

        rules.append({"type": type_key, "amount": amount, "pattern": pattern,
                      "payee": payee, "category": category})
    return rules


def find_matching_rule(rules, amount, type_key, text):
    """Find the rule whose whose amount and/or type, if present match the
    transaction and the regex matches the text."""
    for rule in rules:
        if rule["type"] and type_key != rule["type"]:
            continue
        if rule["amount"] and amount != rule["amount"]:
            continue
        if rule["pattern"].match(text):
            return rule

    return None


class Transaction:
    """A parsed and later converted transaction."""

    def __init__(self, xml_txn):
        self._unstructured_info = get_transaction_unstructured_info(xml_txn)
        self._date = get_transaction_date(xml_txn)
        self._amount = get_transaction_amount(xml_txn)
        self._creditor = get_creditor(xml_txn)
        self._debitor = get_debitor(xml_txn)
        self._transaction_type = get_transaction_type(xml_txn)
        self._domain, self._family, self._subfamily = parse_txn_codes(xml_txn)
        self._rule_type = get_rule(self._transaction_type, self._domain,
                                   self._family, self._subfamily)
        self._payee = ""
        self._category = ""

    def __str__(self):
        return (
            f"Transaction(date: {self._date}, amount: {self._amount}, "
            f"creditor: {self._creditor}, debitor: {self._debitor}, "
            f"unstructured_info: {self._unstructured_info}, "
            f"type: {self._transaction_type}, domain: {self._domain}, "
            f"family: {self._family}, subfamily: {self._subfamily}, "
            f"rule_type: {self._rule_type}, payee: {self._payee}, "
            f"category: {self._category})"
        )

    def add_fields_by_rule(self, rules):
        """Find a matching rule for transaction processing and apply it"""
        rewrite_rule = None
        if self._debitor:
            rewrite_rule = find_matching_rule(rules, self._amount,
                                              self._rule_type, self._debitor)
        if rewrite_rule is None and self._creditor:
            rewrite_rule = find_matching_rule(rules, self._amount,
                                              self._rule_type, self._creditor)
        if rewrite_rule is None:
            rewrite_rule = find_matching_rule(rules, self._amount,
                                              self._rule_type,
                                              self._unstructured_info)
        if rewrite_rule is None:
            raise ValueError(f"Please add a rule for {self._creditor}, "
                             f"{self._debitor} or {self._unstructured_info}")

        self._payee = rewrite_rule["payee"]
        self._category = rewrite_rule["category"]

    def rule_fields(self):
        """Get a string with processed fields only"""
        return (
            f"Transaction rule fields(payee: {self._payee}, "
            f"category: {self._category})"
        )

    @property
    def date(self):
        """Get the transaction date."""
        return self._date

    @property
    def type(self):
        """Get the transactino type."""
        return self._transaction_type

    @property
    def amount(self):
        """Get the transaction amount."""
        return self._amount

    @property
    def payee(self):
        """Get the transaction payee."""
        return self._payee

    @property
    def category(self):
        """Get the transaction category."""
        return self._category


def get_transaction_unstructured_info(txn):
    """Get the unstructured information from the transcation"""
    unstructured_info_obj = txn.find(XPATH_UNSTRUCTURED, NS)
    if unstructured_info_obj is None:
        return ""
    return unstructured_info_obj.text


def get_transaction_date(txn):
    """Get the transaction date from the transaction"""
    value_date = txn.find(XPATH_VALUE_DATE, NS)
    if value_date is not None:
        return value_date.text

    unstructured_info = get_transaction_unstructured_info(txn)
    if unstructured_info and US_DATE_PREFIX.match(unstructured_info):
        date_substr = unstructured_info[:10]
        date_obj = datetime.strptime(date_substr, "%d/%m/%Y")
        return date_obj.strftime("%Y-%m-%d")

    booking_date = txn.find(XPATH_BOOKING_DATE, NS)
    if booking_date is not None:
        return booking_date.text

    raise ValueError("Don't know how to get the transaction date from the "
                     "transaction")


def get_transaction_amount(txn):
    """Get the transaction amount from the transaction"""
    amount_node = txn.find(XPATH_AMOUNT, NS)
    if amount_node is None:
        raise ValueError("Unable to find amount in the transaction")
    return amount_node.text


def get_creditor(txn):
    """Get the creditor or empty string from the transaction"""
    creditor_node = txn.find(XPATH_CREDITOR, NS)
    return creditor_node.text if creditor_node is not None else ""


def get_debitor(txn):
    """Get the debitor or empty string from the transaction"""
    debitor_node = txn.find(XPATH_DEBITOR, NS)
    return debitor_node.text if debitor_node is not None else ""


def get_transaction_type(txn):
    """Get the transaction type from the transaction"""
    type_indicator_obj = txn.find(XPATH_TYPE_INDICATOR, NS)
    if type_indicator_obj is None:
        raise ValueError("Unable to find transaction type indicator")
    type_indicator_str = type_indicator_obj.text
    # pylint: disable=E1101
    return TransactionType.from_string(type_indicator_str)
    # pylint: enable=E1101


def get_transaction_domain(txn):
    """Get the transaction domain from the transaction"""
    domain_obj = txn.find(XPATH_DOMAIN, NS)
    if domain_obj is None:
        raise ValueError("Unable to find transaction domain code")
    domain_str = domain_obj.text
    return TransactionDomain.from_string(domain_str)  # pylint: disable=E1101


def get_transaction_family_string(txn):
    """Get the transaction family string."""
    family_obj = txn.find(XPATH_FAMILY, NS)
    if family_obj is None:
        raise ValueError("Unable to find transaction family code")
    return family_obj.text


def get_transaction_subfamily_string(txn):
    """Get the transaction subfamily string."""
    subfamily_obj = txn.find(XPATH_SUBFAMILY, NS)
    if subfamily_obj is None:
        raise ValueError("Unable to find transaction subfamily code")
    return subfamily_obj.text


def parse_txn_codes(txn):
    """Parse the transaction codes to return domain, family, & subfamily"""
    domain = get_transaction_domain(txn)
    family_str = get_transaction_family_string(txn)
    subfamily_str = get_transaction_subfamily_string(txn)
    # pylint: disable=E1101
    if domain == TransactionDomain.PAYMENTS:
        family = PaymentsTransactionFamily.from_string(family_str)
        if family == PaymentsTransactionFamily.CUSTOMER_CARD_TRANSACTION:
            subfamily = CCRDTransactionSubfamily.from_string(subfamily_str)
        elif family == PaymentsTransactionFamily.ISSUED_CREDIT_TRANSFER:
            subfamily = ICDTTransactionSubfamily.from_string(subfamily_str)
        elif family == PaymentsTransactionFamily.OTHER:
            subfamily = OtherTransactionSubfamily.from_string(subfamily_str)
        else:
            subfamily = ""
    elif domain == TransactionDomain.LOANS_DEPOSITS_SYNDICATIONS:
        family = LDASTransactionFamily.from_string(family_str)
        if family == LDASTransactionFamily.MISC_DEBIT_OPS:
            subfamily = MiscDebitOpsTransactionSubfamily.from_string(
                subfamily_str)
        elif family == LDASTransactionFamily.FIXED_TERM_LOANS:
            subfamily = FixedTermLoanTransactionSubfamily.from_string(
                subfamily_str)
        else:
            subfamily = ""
    else:
        family = ""
    # pylint: enable=E1101
    return domain, family, subfamily


def get_rule(transaction_type, domain, family, subfamily):
    """Get the ad-hoc rule type from the transaction parameters."""
    if transaction_type == TransactionType.DEPOSIT:
        return "deposit"
    if domain == TransactionDomain.LOANS_DEPOSITS_SYNDICATIONS:
        return "loan"
    if domain == TransactionDomain.PAYMENTS:
        if (family == PaymentsTransactionFamily.CUSTOMER_CARD_TRANSACTION
                and subfamily == CCRDTransactionSubfamily.FEES):
            return "card_fee"
        if (family == PaymentsTransactionFamily.OTHER
                and subfamily == OtherTransactionSubfamily.OTHER):
            return "bank_service"
    return ""


def process_transactions(root, rules):
    """Convert all the transactions in the given XML document root"""
    for xml_txn in root.findall(XPATH_TRANSACTIONS, NS):
        transaction = Transaction(xml_txn)

        print(f"Before: {transaction}")

        transaction.add_fields_by_rule(rules)

        print(f"After: {transaction.rule_fields()}")

        output_file.write(f"D{transaction.date}\n")
        if transaction.type == TransactionType.DEPOSIT:
            output_file.write(f"T{transaction.amount}\n")
        elif transaction.type == TransactionType.WITHDRAWAL:
            output_file.write(f"T-{transaction.amount}\n")
        else:
            raise ValueError(f"Unknown transaction type {transaction.type}")
        output_file.write(f"P{transaction.payee}\n")
        output_file.write(f"L{transaction.category}\n")
        output_file.write("^\n")


arg_parser = argparse.ArgumentParser(
    description="Convert bank statement in XML format (camt.053) to QIF for "
    "importing to Banktivity."
)

arg_parser.add_argument("input", type=str, help="The input file")
arg_parser.add_argument("output", type=str, help="The output file")

args = arg_parser.parse_args()

rule_config = configparser.ConfigParser()
rule_config.read(os.path.expanduser(CONFIG_FN))

rewrite_rules = collect_rules(rule_config)

print(f"Rules loaded from {CONFIG_FN}: {len(rewrite_rules)}")

print(f"Processing {args.input} to {args.output}")

tree = ET.parse(args.input)

xml_root = tree.getroot()

with open(args.output, "w", encoding="utf-8") as output_file:
    output_file.write("!Type:Bank\n")
    process_transactions(xml_root, rewrite_rules)
